#!/usr/bin/env node

// eslint-disable-next-line import/no-nodejs-modules, import/no-commonjs
const fs = require('fs')

async function init() {
  let currentCoverage = {}
  try {
    const currentCoverageData = fs.readFileSync('packages/react/coverage/coverage-summary.json', 'utf8')
    currentCoverage = JSON.parse(currentCoverageData)
  } catch (error) {
    // eslint-disable-next-line no-console
    console.log('No current React coverage found')
    return
  }

  let mainCoverage = {}
  try {
    const mainCoverageData = fs.readFileSync('main/packages/react/coverage/coverage-summary.json', 'utf8')
    mainCoverage = JSON.parse(mainCoverageData)
  } catch (error) {
    // eslint-disable-next-line no-console
    console.log('No main branch React coverage found, will show current coverage only')
  }

  // Calculate differences for total coverage
  const calculateDiff = (current, mainBranch) => {
    if (!mainBranch) return {value: current, diff: 0, isNew: true}
    const diff = current - mainBranch
    return {value: current, diff, isNew: false}
  }

  const currentTotal = currentCoverage.total || {}
  const mainTotal = mainCoverage.total || {}

  const totalLinesDiff = calculateDiff(currentTotal.lines?.pct || 0, mainTotal.lines?.pct)

  const componentChanges = []
  let totalComponentsSearched = 0

  // Only compare components if we have main coverage data
  if (mainCoverage.total) {
    // Normalize file paths to handle different absolute paths and main/ subfolder
    const normalizeFilePath = filePath => {
      // Extract the relative path from packages/react/ onwards, handling both:
      const match = filePath.match(/(?:main\/)?packages\/react\/(.+)$/)
      return match ? `/packages/react/${match[1]}` : filePath
    }

    // Create normalized maps for comparison - include ALL files Jest reports
    const currentNormalized = {}
    const mainNormalized = {}

    // Process current coverage files
    for (const filePath of Object.keys(currentCoverage)) {
      if (filePath !== 'total') {
        const normalizedPath = normalizeFilePath(filePath)
        currentNormalized[normalizedPath] = currentCoverage[filePath]
      }
    }

    // Process main coverage files
    for (const filePath of Object.keys(mainCoverage)) {
      if (filePath !== 'total') {
        const normalizedPath = normalizeFilePath(filePath)
        mainNormalized[normalizedPath] = mainCoverage[filePath]
      }
    }

    // Get all unique normalized file paths
    const allFiles = [...new Set([...Object.keys(currentNormalized), ...Object.keys(mainNormalized)])]
    totalComponentsSearched = allFiles.length

    for (const filePath of allFiles) {
      const current = currentNormalized[filePath]
      const main = mainNormalized[filePath]

      // Extract component/file name for display
      const fileMatch = filePath.match(/\/([^/]+)$/)
      const fileName = fileMatch ? fileMatch[1] : filePath

      const currentPct = current?.lines?.pct || 0
      const mainPct = main?.lines?.pct || 0
      const diff = currentPct - mainPct

      // Only include if there's a significant change OR if file is truly new/removed
      if (Math.abs(diff) > 0.1 || (!main && current) || (main && !current)) {
        componentChanges.push({
          component: fileName,
          file: filePath,
          current: currentPct,
          main: mainPct,
          diff,
          isNew: !main && current,
          isRemoved: main && !current,
        })
      }
    }
  } else {
    // eslint-disable-next-line no-console
    console.log('No main branch coverage data available, skipping component comparison')
  }

  // Filter out components with no significant changes after merging
  const significantChanges = componentChanges.filter(change => {
    return Math.abs(change.diff) > 0.1 || change.isNew || change.isRemoved
  })

  // Sort by largest change first
  significantChanges.sort((a, b) => Math.abs(b.diff) - Math.abs(a.diff))

  const hasSignificantTotalChange = Math.abs(totalLinesDiff.diff) > 0.1 && mainCoverage.total
  const hasComponentChanges = significantChanges.length > 0

  // Bail out if nothing to report or if there's no main branch coverage to compare against
  if ((!hasSignificantTotalChange && !hasComponentChanges) || !mainCoverage.total) {
    if (!mainCoverage.total) {
      // eslint-disable-next-line no-console
      console.log('No main branch coverage found for comparison. This is expected for workflow/infrastructure changes.')
    } else {
      // eslint-disable-next-line no-console
      console.log('No significant coverage changes detected. Skipping comment creation.')
    }
    return
  }

  const formatDiff = (diff, isNew = false, isRemoved = false) => {
    if (isNew) return `🆕 ${diff.toFixed(1)}%`
    if (isRemoved) return `🗑️ Removed`
    if (Math.abs(diff) < 0.1) return `${diff.toFixed(1)}% ➡️`

    const sign = diff > 0 ? '+' : ''
    const color = diff > 0 ? '🟢' : '🔴'
    return `${sign}${diff.toFixed(1)}% ${color}`
  }

  const formatCoverage = pct => `${pct.toFixed(1)}%`

  let commentBody = `## Components coverage report\n\n`

  const totalSign = totalLinesDiff.diff > 0 ? '+' : ''
  const totalEmoji = totalLinesDiff.diff > 0 ? '🟢' : totalLinesDiff.diff < 0 ? '🔴' : '➡️'

  commentBody += `### Overall Coverage\n`
  commentBody += `**Lines**: ${formatCoverage(totalLinesDiff.value)}`
  if (mainCoverage.total) {
    commentBody += ` (${totalSign}${totalLinesDiff.diff.toFixed(1)}%) ${totalEmoji}`
  } else {
    commentBody += ` (baseline)`
  }
  commentBody += `\n\n`

  // Table
  if (significantChanges.length > 0) {
    commentBody += `### ⚠️ File changes\n\n`
    commentBody += `| File | Coverage | Change |\n`
    commentBody += `|------|----------|--------|\n`

    for (const change of significantChanges) {
      const coverageDisplay = change.isRemoved ? 'N/A' : formatCoverage(change.current)
      const changeDisplay = formatDiff(change.diff, change.isNew, change.isRemoved)

      commentBody += `| **${change.component}** | ${coverageDisplay} | ${changeDisplay} |\n`
    }
    commentBody += `\n`
  } else {
    commentBody += `### No file coverage changes\n\n`
  }

  // Summarize
  const significantDecrease = significantChanges.some(c => c.diff < -1.0)
  const significantIncrease = significantChanges.some(c => c.diff > 1.0)
  const newComponents = significantChanges.some(c => c.isNew)
  const removedComponents = significantChanges.some(c => c.isRemoved)

  if (significantDecrease) {
    commentBody += `⚠️ **Coverage decreased** - This could mean:\n`
    commentBody += `- New features were added without corresponding tests\n`
    commentBody += `- Tests were removed or modified\n`
  } else if (significantIncrease) {
    commentBody += `**Coverage increased** - This could mean:\n`
    commentBody += `- New tests were added\n`
    commentBody += `- Test coverage was improved\n`
    commentBody += `- Great work on testing!\n\n`
  } else if (newComponents) {
    commentBody += `**New files detected** - Make sure they have adequate test coverage.\n\n`
  } else if (removedComponents) {
    commentBody += `**Files removed** - Coverage data updated accordingly.\n\n`
  } else {
    // eslint-disable-next-line i18n-text/no-en
    commentBody += `Nothing to see here \n\n`
  }

  // eslint-disable-next-line github/unescaped-html-literal
  commentBody += `<details>\n<summary>Coverage details</summary>\n\n`
  commentBody += `**React Package Coverage**:\n`
  commentBody += `- **Current PR**: ${currentTotal.lines?.covered || 0}/${
    currentTotal.lines?.total || 0
  } lines covered\n`
  if (mainCoverage.total) {
    commentBody += `- **Main branch**: ${mainTotal.lines?.covered || 0}/${mainTotal.lines?.total || 0} lines covered\n`
  }
  commentBody += `- **Files searched**: ${totalComponentsSearched > 0 ? totalComponentsSearched : 'No changes'}\n`
  commentBody += `\n</details>`

  // Output the comment body to be used by the GitHub Action
  return commentBody
}

// eslint-disable-next-line import/no-commonjs
module.exports = init
